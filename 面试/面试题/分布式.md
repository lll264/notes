# RPC

## 什么RPC？作用优点?

RPC是**远程调用通信协议**，允许程序像调用本地函数一样调用远程服务器上的函数或方法，从而解决不同服务器之间的通信及数据传输问题。

**作用优点**：

- **简化通信**：RPC框架隐藏了网络通信的细节，让开发者不需要网络编程，可以像调用本地方法一样调用远程服务。
- **高效率**：RPC框架如gRPC通常基于高效的二进制协议，传输效率更高。

## RPC工作原理/过程

**客户端请求**：客户端**调用本地函数时，RPC框架会将函数调用转化为一个远程请求**，其会将客户端的请求数据（包括函数名、参数等）**序列化成网络传输数据格式**（如JSON、Protobuf等），然后通过网络发送到远程服务器。

**服务端解析**：服务器端接收到来自客户端的请求后，RPC框架会**解析请求，反序列化得到函数名和参数信息。**

**执行函数：**服务器找到请求对应的本地函数，并利用传过来的参数执行该函数。

**返回结果：**执行完成后，服务器将结果进行序列化，并通过网络发送回客户端。客户端反序列化得到结果数据。

## RPC调用和HTTP调用的比较

- **传输协议**：HTTP调用只能使用应用层HTTP协议，但是**RPC可以使用自定义的传输协议**，比如HTTP协议或传输层TCP协议
- **简化通信：**HTTP方式中，客户端需要发送GET或POST请求，然后接收服务端的响应并处理。**RPC隐藏了请求和响应的过程**，客户端只需要调用本地方法来调用远程服务。
- **性能和效率：**RPC框架使用**高效的二进制协议**，占用更小的带宽，序列化和反序列化速度更快，性能和传输效率更高
- **简单与复杂**：RPC比较复杂，需要定义服务接口，使用RPC框架，但是HTTP使用RESTful API易于理解和使用，能够快速上手。

## RPC和消息队列比较

**实时和异步**：RPC一般是同步通信，客户端RPC相比之下，发起请求后会等待服务端的响应，适用于实时性高的场景。消息队列一般用于异步通信，不适合要求即时响应的场景。

**耦合性：**RPC接口定义（如IDL）需要在客户端和服务器之间保持一致，耦合性较高，而消息队列实现了服务解耦，

**容错性：**消息队列还支持消息持久化和重试机制，容错能力较强

# 消息队列

## 杂

**消息队列意义**

**异步处理**，比如一个电商系统，用户下单功能可能涉及到扣除优惠券、增减用户积分的操作，导致用户下单等待时间长，因此通过消息队列异步执行这些操作可以降低响应时间。

**解耦**，消费者通过消息队列主动订阅消息来执行相应的操作，降低了服务之间的耦合性

**削峰**，在高并发的场景下，通过消息队列存下了大量的请求，慢慢的消化处理，降低了服务的压力

**高性能**，可以增加消息队列的消费者和生产者，提高消息处理效率，但为了降低冲突，队列划分了不同的topic，每个topic有划分为了多个分区。

**高扩展性**，分区可以分布在不同的机器上，每个机器都是broker，从而缓解一台机器的压力

**高可用**，如果一个broker挂了，那么其中的所有分区的消息都没了，为了避免消息丢失，消息队列为分区增加多个副本（replicas），它们分为leader和follower，leader负责读写请求，而follower会同步leader的消息，副本分布在不同的broker中，这样即使一个broker挂了，也不影响副本的消息。

**持久化和过期策略**，如果所有broker都挂了，那么消息就真的丢失了，因此需要持久化消息到磁盘中，机器重启后也能从磁盘中读取到未处理的消息，同时磁盘空间也有限，需要清理消息，比如消息放置超过一定时间就会清理掉。

消费者组，不同消费者组维护自己的消费进度，互不打搅



## 消息队列结构

每个broker包含多个topic代表不同业务，topic下包含多个分区，每个分区都是一个队列。生产者发送消息时会发送到对应topic下的各个分区中，消费者订阅topic后，从这些分区中获取消息。

## 什么是消息队列，作用是什么？

消息队列是分布式系统中一种消息传递的中间件，生产者可以将消息存储在队列中，直到接收者能够处理这些消息为止。

**核心作用：**

- **异步处理**：用户请求数据写入消息队列后可以直接返回，从而降低响应时间，提高用户体验，而其他额外的操作由消费者获取消息异步处理。
- **解耦：**客户端不直接调用服务端，而是消费者主动订阅消息来执行相应的操作，不会与其他模块有关联。对于新增业务，只需订阅相关消息即可，对原有系统没有任何影响，降低了模块之间的耦合性，提高了程序的扩展性。
- **削峰或流量控制：**在高并发的场景下，通过消息队列存下了大量的请求，慢慢的消化处理，降低了服务器的压力。
- **高可用**：消息队列提供了重试机制，如果消费者处理失败，消息会重新放回直到消费者成功处理消息。这样可以保障系统的可靠性，并避免丢失重要数据。

## 使用消息队列的缺点

- **可用性降低**：系统引入了消息队列这个外部依赖，如果消息队列崩溃了，那么系统就不可用了。
- **复杂度高**：引入消息队列后，需要考虑的问题更多，比如消息顺序处理、重复消费幂等性问题、消息丢失的问题

## 如何解决消息丢失问题？

- **生产者**：**生产者应该采用同步发送的方式**，发送消息后，需要等待Broker的确认响应，如果broker返回写入失败，还需要重试发送，确保消息成功写入。
- **消息存储方**：
  - 持久化策略：为了防止数据丢失，消息存储方会**持久化**消息到磁盘，刷盘策略需采用**同步刷盘**，消息到达mq后，需持久化后再返回响应，如果是异步刷盘的话，只要消息放到mq缓存中，就返回响应了，会有消息丢失的风险。
  - 考虑**集群部署**mq服务，每个数据分区都有副本分布在不同的Broker中，主节点会同步数据到从节点中，这样就避免单点故障数据丢失的问题（但是主从同步降低了系统的吞吐量）
- **消费者**：消费者同样需开启**ack确认机制**，然后不能够异步处理，只有正确处理完成后，才返回确认，没有收到确认就重试，保证消费过程中消息不丢失。

## 如何保证消息的顺序性

对于某些业务场景，可能需要保证消息处理的顺序，比如用户下单、付款、发货这些步骤必须按顺序进行。

- 首先生产者只能有一个，必须同步发送，不能异步发送，保证发送消息是按顺序发送，不能够并发，并且要将业务的**消息统一发送到同一个分区中**，kafka可以通过key值指定对应的分区，rabbitmq可以进行通过哈希计算选择分区
- 消费者也只能有一个，并且这个消费者不能够异步执行操作，必须同步执行，要保证消息执行是按顺序的。

## 消息有可能发生重复消费吗？如何幂等处理？

**重复消费场景**：

- 生产者发送消息后，mq的响应在网络中丢失了生产者没收到响应，重发了一遍消息，
- 当消费者处理完成后返回给mq ack确认时，如果ack确认再网络中丢失，那么mq就会认为消费者没有处理完成，因此会保留这个消息，从而导致重复处理。

**解决方案**：

1.简单来讲就是可以为消息设置一个根据业务进行表示的全局id，比如说电商系统的订单号，数据库为这个订单号设置唯一索引，每次处理业务，先校验一下就好啦。或者使用redis缓存这个消息业务操作，每次操作都从缓存中查询判断这个消息是否处理过了。

2.布隆过滤器存储执行完成的消息，每次执行操作时，先判断布隆过滤器中是否存在，存在则不执行。但是误判风险大，很严重。

## 如何处理消息队列的消息积压问题？

消息积压是因为生产者的生产速度，大于消费者的消费速度。

可以优化一下消费的逻辑，比如之前是一条一条消息消费处理的话，我们可以确认是不是可以优为**批量处理消息**。

如果还是慢，我们可以考虑**水平扩容**，增加Topic的队列数，和消费组机器的数量，提升整体消费能力。

## 消息中间件如何做到高可用？（小）

- 采用分布式架构：每个 partition 的数据都会同步到其它机器上，形成多个副本。然后所有的副本会选举一个 leader 出来，让leader去跟生产和消费者打交道，其他副本都是follower。写数据时，leader 负责把数据同步给所有的follower，读消息时， 直接读 leader 上的数据即可。如何保证高可用的？就是假设某个 broker 宕机，这个broker上的partition 在其他机器上都有副本的。如果挂的是leader的broker呢？其他follower会重新选一个leader出来。
- 可以水平扩展
- 支持负载均衡

## 如何保证数据一致性，事务消息如何实现（小）

分布式事务

## 流行的消息队列技术比较

kafka吞吐量和性能较高，但是rabbitMQ稳定性和可用性更好，原因？

。。。。。



![在这里插入图片描述](D:\E\学习\Go\笔记\面试\面试题\assets\858b8968f9ca4192929b50fdf637c78f.png)

## 如果让你写一个消息队列，该如何进行架构设计？（小）

![在这里插入图片描述](D:\E\学习\Go\笔记\面试\面试题\assets\ef87df2acdb94cda98367a670919c1ef.png)

# 分布式

## CAP定理

## 分布式事务

两阶段提交：

最终一致：
