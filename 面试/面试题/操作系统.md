# 操作系统

## 硬件结构

### 如何写出让 CPU 跑得更快的代码

本质就是提高CPU缓存命中率

- 对于数据缓存，我们在遍历数据的时候，应该按照内存布局的顺序操作，这是因为 CPU Cache 是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时，性能能得到有效的提升；
- 对于指令缓存，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率；

另外，对于多核 CPU 系统，线程可能在不同 CPU 核心来回切换，这样各个核心的缓存命中率就会受到影响，于是要想提高线程的缓存命中率，可以考虑把线程绑定 CPU 到某一个 CPU 核心。

## 基础

### 用户态与核心态

⽤户态 User Mode 和核⼼态 Kernel Mode ，**是操作系统中两种不同的执⾏模式**，⽤于控制进程或程序**对计算机硬件资源的访问权限和操作范围。**

- ⽤户态：在⽤户态下，进程或程序**只能访问受限的资源和执⾏受限的指令集，**不能直接访问操作系统的**核⼼部分以及硬件资源**
- 核⼼态：核⼼态是操作系统的特权级别，允许进程或程序**执⾏特权指令和访问操作系统的核⼼部分。**在核⼼态下，进程**可以直接访问硬件资源，执⾏系统调⽤，管理内存、⽂件系统等操作。**

### 中断和异常

#### 什么是中断和异常？它们有什么区别？

中断和异常是两种不同的事件，它们都会导致CPU暂停当前的程序执⾏，转⽽去执⾏中断或异常处理逻辑

- 中断：中断是**系统用来响应硬件设备请求的一种机制**，CPU在执行指令时，收到硬件的中断请求，会打断正在执行的进程，保存当前状态，然后调用内核中的中断处理程序来响应请求。
- 异常：异常是指由于**CPU执行指令时发生了错误而引发的事件**。例如除以零、访问非法内存、执行非法指令等。当异常发生时，CPU会立即暂停当前执行的程序，保存当前状态，并转到异常处理程序执行相应的处理逻辑

它们的区别：

**触发原因**：中断是由外部设备或系统事件触发的产生是异步的，也就是任何时刻都可能发生，与CPU当前执行的指令无关。而异常则是由CPU执行指令时发生的错误或非正常情况导致的，是同步产生。

**中断可以被屏蔽或禁止：**CPU可以通过**设置某些标志位或寄存器来忽略或延迟响应某些中断信号**。这样可以避免中断过于频繁或⼲扰重要的任务。但是异常必须⽴即响应，并进⾏相应的处理。这样可以保证程序的正确性和系统的稳定性。

## 内存管理

### 什么是虚拟内存？为什么要有虚拟内存？

**操作系统会为每个新创建的进程分配一段连续的地址空间，它不是真实的物理地址，而是通过映射与实际物理地址对应**。这样每个进程就都有自己的独立的内存空间，而不是共用实际物理内存，造成冲突

使用虚拟内存的总结如下：

**内存隔离**：虚拟内存让进程之间内存隔离。每个进程都有⾃⼰的虚拟地址空间，因此⼀个进程⽆法直接访问另⼀个进程的内存，解决了地址冲突的问题。

**内存扩展**： 虚拟内存利用磁盘暂存数据，使得每个程序都可以使⽤⽐实际可⽤内存更多的内存，从⽽允许运⾏更⼤的程序或处理更多的数据。

**高效管理内存**：允许操作系统更加灵活地管理和分配内存资源，通过内存映射可以将物理内存分配给多个进程。内存分页和页面置换算法等机制，**实现内存资源的动态调配和优化利用。**

### 内存分段和分页

#### 什么是内存分段与分页？作用是什么？

**内存分段**是将⼀个程序的内存空间分为不同的逻辑段 segments ，每个段代表程序的⼀个功能模块
或数据类型，如代码段、数据段、堆栈段等。每个段都有其⾃⼰的⼤⼩和权限。

**内存分⻚**是把整个虚拟和物理内存空间分成固定⼤⼩的⻚(如4KB)。这样⼀个连续并且尺⼨固定的内
存空间，我们叫⻚ Page

内存隔离、内存扩展

分段**更符合程序的逻辑结构，便于程序管理**；分页因为**页面大小固定，因此易于部分内存部分加载和交换，**减少了外部碎片，提高了内存利用率。

### 页面置换算法

- LRU（最近最久未使⽤）算法：发生缺页时，**选择最长时间没有被访问的页面进行置换**
- FIFO（先进先出）算法：**每次选择最早进⼊内存的页面进⾏切换。**
- OPT 最佳⻚⾯置换算法：置换在「未来」最⻓时间不访问的⻚⾯,但是实际系统中⽆法实现，因为程序访问⻚⾯时是动态的我们是⽆法预知每个⻚⾯在「下⼀次」访问前的等待时间
- 时钟置换算法：fifo先进先出算法的改进。

## 进程管理

### 进程与线程的区别

进程是是程序的一次执行过程，是系统进⾏**资源分配和调度的基本单位**。线程 Thread 是**操作系统能够进⾏运算调度的最⼩单位**，线程是进程的⼦任务。 ⼀个进程可以运⾏多个线程，这些线程共享同⼀块内存。

- **通信**：由于**进程与进程之间是相互隔离的，进程之间的通信需要使⽤⼀些特殊机制**，如管道、消息队列、信号量等。由于线程共享相同的内存空间，它们之间可以直接访问共享数据，**线程间通信更加⽅便**。
- **开销**：由于每个进程都有独⽴的内存空间，**创建和销毁进程的开销较⼤**。进程间切换需要保存和恢复整个进程的状态，因此**上下⽂切换的开销较⾼**。线程共享相同的内存空间，创建和销毁线程的开销较⼩。而**线程间切换只需要保存和恢复少量的线程上下文**，因此上下⽂切换的开销较⼩。
- **安全性：**由于进程间相互隔离，⼀个进程的崩溃不会直接影响其他进程的稳定性。线程共享相同的内存空间，⼀个线程的错误可能会影响整个进程的稳定性。

### 进程调度算法

- **先来先服务算法（FCFS）**：按照进程到达的先后顺序进⾏调度，即最早到达的进程先执⾏，直到完成或阻塞。
- **最短作业优先调度算法**：优先选择运⾏时间最短的进程来运⾏。
- **高响应比优先调度算法**：综合考虑等待时间和服务时间的⽐率，选择具有最⾼响应⽐的进程来执⾏
- **时间片轮转调度算法**：将 CPU 时间划分为一个个的时间⽚（时间量），每个进程在⼀个时间⽚内运⾏，然后切换到下⼀个进程。
- **最⾼优先级调度算法**：为每个进程分配⼀个优先级，优先级较⾼的进程先执⾏。这可能导致低优先级进程⻓时间等待，可能引发饥饿问题。
- **多级反馈队列调度算法**：将进程划分到多个队列中，**每个队列具有不同的优先级，进程在队列之间移动。**具有更⾼优先级的队列的进程会更早执⾏，⽽⻓时间等待的进程会被提升到更⾼优先级队列。**相比于最高优先级调度避免了饥饿的问题。**

### 进程有哪些通信方式

- **管道**：**是⼀种半双⼯的通信⽅式，遵循先进先出的原则，传输数据是无格式的字节流**。常在具有⽗⼦进程关系的进程间使⽤。通信效率很低，不适合频繁交换大量数据。
- **消息队列**：**消息队列是存放在内核中的消息的链表**。允许进程向其中发送和接收消息进行通信。解决了管道只能承载⽆格式字节流以及缓冲区⼤⼩受限等问题。可以传输更多数据。
- **共享内存**：**允许多个进程访问同一块内存区域，从而实现快速的数据交换**。这种方式是效率最高的进程间通信方式，但是需要互斥与同步操作，比如说加锁或信号量控制，以防止数据冲突与竞争。
- **信号量**：**是⼀个计数器，可以⽤来控制多个进程对共享资源的访问**，通过PV操作进程阻塞与换醒，实现进程之间的同步与互斥。

#### 为什么共享内存最高效

无需频繁地进行系统调用。

### 进程同步和互斥

#### 解释一下什么是进程同步和互斥

进程同步是指多个并发执⾏的进程之间协调和管理它们的执⾏顺序，**以确保它们按照⼀定的顺序或时**
**间间隔执⾏。**

互斥指的是在某⼀时刻只允许⼀个进程访问某个共享资源。当⼀个进程正在使⽤共享资源时，其他进
程不能同时访问该资源。

#### pv操作实现

举个例子

### 死锁

#### 什么是死锁？死锁产生的条件？如何避免死锁？

**死锁**：**`两个或多个进程在争夺系统资源时，由于互相等待对⽅释放资源⽽自己⽆法继续执⾏的状态。`**

死锁只有同时满⾜以下四个条件才会发⽣：

- **互斥条件**：⼀个进程占⽤了某个资源时，其他进程⽆法同时占⽤该资源。
- **占有等待条件**：⼀个线程因为请求资源⽽阻塞的时候，不会释放⾃⼰的资源。
- **不可剥夺条件**：资源不能被强制性地从⼀个进程中剥夺，只能由持有者⾃愿释放。
- **环路等待条件**：多个进程之间形成⼀个循环等待资源的循环链，每个进程都在等待下⼀个进程所占有的资源。

只需要破坏上⾯⼀个条件就可以破坏死锁。

- 破坏请求与保持条件：**⼀次性申请所有的资源。**
- 破坏不可剥夺条件：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
- 破坏环路等待条件：靠**按序申请资源**来预防。让所有进程按照相同的顺序请求资源，释放资源则反序释放。

### 几种典型的锁

#### 互斥锁与自旋锁

互斥锁与自旋锁是最基础的锁，其他锁都是基于这两种锁实现的。

**互斥锁**

- 当一个线程尝试获取锁时，如果锁已经被其他线程持有，**当前线程会被挂起进入阻塞状态，直到锁被释放，系统会唤醒该线程并让它继续执行。**
- **上下文切换的开销较大**，频繁的上下文切换可能导致性能下降。**但互斥锁能够更好的利用CPU资源**。
- 互斥锁适用于锁定时间较长的临界区，以及当线程竞争资源时的情况，

**自旋锁**

- 自旋锁：当一个线程尝试获取锁时，如果锁已经被其他线程持有，当前线程不会进入休眠或阻塞状态，而是**占用CPU不断地循环检查（“自旋”）锁是否已经释放，直到获取锁为止。**
- 相比于互斥锁没有线程切换中上下文切换的开销，但自旋会**消耗大量的CPU资源**，可能导致性能下降。
- **适合于加锁时间短的场景。**

#### 悲观锁与乐观锁

**悲观锁**

悲观锁是一种悲观的思想，它总是认为最坏的情况会出现，也就是共享数据会被其他线程修改，所以悲观锁在操作共享数据的时候，会将数据锁住，其他线程再访问这个共享数据的时候就会被阻塞，直到锁释放。

**乐观锁**

乐观锁正好与悲观锁相反，它总认为资源和数据不会被别人所修改，所以不会进行上锁操作。乐观锁是通过CAS操作实现，CAS操作首先需要读取数据，通过比较当前值与读取的值判断数据是否已经被其他线程修改，如果没被修改就可以正常进行操作，否则循环重复判断，直到修改成功。

#### 乐观锁实现方式

### 进程、线程、协程上下文切换开销？

进程上下文需哟保存**CPU寄存器和程序计数器PC，以及内存管理信息比如页表、段表**。进程切换涉及到段表、页表的更新，进程地址的切换，增加了开销。

线程上下文只需要保存线程的独有的信息，比如**堆栈信息，寄存器状态**。

协程切换只需要保存和恢复**协程的栈帧信息，以及一些额外的状态信息，如指令指针**等。由于协程是在用户态管理的，无需涉及操作系统的内核调度和内存管理，因此协程切换的开销最小。

程序计数器保存当前CPU执行的指令

### 为什么内核态的切换比用户态慢？