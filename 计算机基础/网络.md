# 一、基础

**H**yper**T**ext **T**ransfer **P**rotocol 超文本传输协议

## 请求报文结构

- 第一行是包含了请求方法、URL、协议版本；
- 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
- 一个空行用来分隔首部和内容主体 Body
- 最后是请求的内容主体

## **http状态码**

- `1xx` 类状态码属于**提示信息**，**是协议处理中的一种中间状态**
  - 101 切换请求协议
- `2xx` 类状态码表示服务器**成功处理了客户端的请求**
  - 200 OK 请求成功
- `3xx` 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。
  - 301 永久重定向，请求的资源已经不存在了
  - 302 临时重定向，请求的资源还在
- `4xx` 类状态码表示**客户端发送的报文有误**，服务器无法处理，也就是错误码的含义。
  - 400 请求错误
  - 404 请求资源在服务器上不存在或未找到
- `5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。
  - 500


## **http首部字段**

`Host字段`，客户端发送请求时，用来**指定服务器的域名。**

`Connection` 字段最常用于**客户端要求服务器使用「HTTP 长连接」机制**，以便其他请求复用。

`Content-Length` 字段，表明**本次回应的数据长度。**

`Content-Type` 字段用于服务器回应时，**告诉客户端，本次数据是什么格式。**

`Content-Encoding` 字段说明**数据的压缩方法。**

## TCP/IP四层模型与OSI七层模型的区别

### 应用层

我们能直接接触到的就是应用层，我们电脑或手机使用的应用软件都是在应用层实现。

所以，应用层**只需要专注于为用户提供应用功能**，比如 HTTP、FTP、Telnet、DNS、SMTP等。

工作在操作系统中的用户态，传输层及以下则工作在内核态。

### 传输层

传输层会有两个传输协议，分别是 TCP 和 UDP。

UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。

TCP 的全称叫传输控制协议（*Transmission Control Protocol*），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。

### 网络层

网络层最常使用的是 IP 协议（*Internet Protocol*），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。

### 网络接口层

生成了 IP 头部之后，接下来要交给**网络接口层**（*Link Layer*）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。

## 键入网址到网页显示，期间发生了什么？

1. 浏览器做的第一步工作就是要**对 `URL` 进行解析**，根据解析出的Web服务器名和文件名**生成http请求信息**
2. DNS域名服务器**获取对方服务器的ip地址**
3. 通过tcp协议实现可靠传输，通过IP协议远程定位，加上mac头部，
4. 将**数字信息转换为电信号**，通过网卡传输

# 二、HTTP篇

## GET和POST的区别

#### 作⽤不同

GET⽤于从服务端获取资源

POST⼀般⽤来向服务器端提交数据

#### 参数传递⽅式不同

GET请求的参数⼀般写在URL中，且只接受ASCII字符，更不安全，不能⽤来传递敏感信息。
POST请求参数⼀般放在请求体中，对于数据类型也没有限制，也更安全。

#### 参数⻓度限制不同

GET传送的数据量较⼩，不能⼤于2KB。
POST传送的数据量较⼤，⼀般被默认为不受限制。

## HTTP缓存技术

### 什么是强缓存和协商缓存？

强缓存和协商缓存是浏览器对静态资源文件的两种缓存机制。

**强缓存**

**强缓存是指浏览器在请求资源时，会先检查本地缓存是否存在该资源的副本，并且判断该副本是否有效。**如果有效，就直接从缓存中获取资源，而不会发送请求到服务器。这种缓存机制依赖于缓存响应头中的`Cache-Control`和`Expires`字段。

- `Cache-Control`字段用于指定缓存资源的有效期，
- `Expires`字段则用于指定缓存资源的过期时间

**协商缓存**

是指**当浏览器发现本地缓存中的资源已经过期时，它会发送一个请求到服务器，询问该资源是否仍然有效。**服务器会根据请求头中的条件标签来判断资源是否发生了变化。

- 没变化，它会返回一个304 Not Modified响应，告诉浏览器可以继续使用本地缓存。
- 已经发生了变化，它会返回新的资源

协商缓存依赖于请求头以及响应头中的字段。

- `If-Modified-Since`浏览器缓存的资源的**最后修改时间**。`Last-Modified`字段是服务器响应中指定的资源**最后修改时间**。
- `If-None-Match`字浏览器缓存的资源的**唯一标识符（ETag）**。`ETag`字段则是服务器为资源生成的一个**唯一标识符**，用于标识资源的版本

## HTTP与HTTPS

### HTTP与HTTPS的区别

### HTTPS工作过程

### HTTPS的优缺点

### 对称加密与非对称加密的区别和原理



## HTTP/1.0 HTTP/1.1 HTTP/2.0 HTTP/3.0

### HTTP1.0和HTTP1.1的区别？

**长连接**

HTTP1.1 ⽀持长连接，每⼀个TCP连接上可以传送多个HTTP请求和响应

HTTP1.0 默认为短连接，每次请求都需要建⽴⼀个TCP连接。

**管道化**

支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求使得请求能够“并⾏”传输，但是响应必须按照请求发出的顺序依次返回，性能在⼀定程度上得到了改善。

**缓存**

HTTP1.0 主要使用If-Modified-Since/Expires 来做为缓存判断的标准

HTTP1.1 则引⼊了更多的缓存控制策略例如 If-None-Match/Entity tag等更多可供
选择的缓存头来控制缓存策略。

### HTTP1.1与HTTP2.0的区别？

**⾸部压缩**

HTTP1.1 不⽀持 header 数据的压缩， HTTP/2.0 使⽤ HPACK 算法对 header
的数据进⾏压缩，这样数据体积⼩了，在⽹络上传输就会更快。⾼效的压缩算法可以很⼤的压缩 h
eader ，减少发送包的数量从⽽降低延迟。

**⼆进制分帧**

全面采用了**二进制格式**，头信息和数据体都是二进制，并且统称为帧（frame），从⽽突破 HT
TP1.1 的性能限制，改进传输性能，实现低延迟和⾼吞吐量。

**多路复⽤（MultiPlexing）**

允许同时通过单⼀的 HTTP/2 连接发起多重的请求-响应消息，这个强⼤的功能则是基于“⼆
进制分帧”的特性。

**服务端推送 （server push）**

在 HTTP/2 中，服务器可以对客户端的⼀个请求发送多个响应，即服务器可以额外的向客户端
推送资源，⽽⽆需客户端明确的请求。

## 谈谈你对HTTP长连接和短连接的理解



# 三、TCP篇

## 三次握手建立连接

### 三次握手过程

- 客户端发送SYN同步报文，并初始化序列号为x，进入SYN_SEND同步已发送状态
- 服务端发送SYN-ACK同步确认报文(ack=x+1)，并初始化序列号为y，进入SYN_RECV同步已接收状态。
- 客户端收到这个报文后，发送确认报文ack=y+1，序列号加1，至此客户端和服务端都进入ESTABLISHED状态。

### 三次握手为什么是三次？

一次握手完全不行，不能同步序列号，没有确认消息，无法知道服务端是否收到了连接请求。

而两次握手中，客户端发送SYN同步请求，服务端返回SYN-ACK同步确认报文，没有第三步客户端的确认。这样也不行

- 三次握手才可以**同步双方的初始序列号（可靠传输的关键）以及确认双发的接收和发送能力。**两次握手中客户端没有返回确认，服务端不知道客户端是否同步成功以及服务端也不能确认客户端的收发能力。
- 三次握手才可以**阻止重复历史连接的初始化（主要原因）并且避免资源浪费。**两次握手中，如果客户端先前已经发送了syn请求，客户端重启后又发送一个syn请求，如果服务端先收到旧的syn同步请求后，就会立刻建立连接，**造成网络异常**。三次握手的话，服务端回复syn+ack包，客户端会对比应答确认号和当前序号，如果发现是旧的报文就会**返回一个rst报文，重新建立连接**。同时**保证了服务端不会收到了syn同步包就建立连接，造成资源浪费**。

## 四次挥手释放连接

### 四次挥手过程

- 当客户端要断开连接时发送FIN报文，初始化序列号为x，进入FIN-WAIT-1状态。
- 服务端搜到FIN报文后，回复确认报文ack=x+1，服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。
- 当服务端要断开连接时发送FIN报文，初始化序列号为y，进入LAST-ACK状态。
- 客户端收到FIN报文后，发送确认报文ack=y+1，进入TIME-WAIT状态。客户端等待 2MSL 没有收到回复，才关闭连接。服务端如果收到了ack就直接进入CLOSE状态。

### 为什么需要四次？



### 为什么需要TIME-WAIT?，等待时间为什么是2MSL?

#### **为什么需要等待一段时间？**

- 网络中可能存在来自发送方的数据包等待被接收。
- 主动关闭方不能保证最后一次挥手ack包到达被动关闭方，所以还要等待一段时间来确认没有被动关闭方的FIN包的超时重传。（如果收到了FIN报文的重传，就重新计时）

#### **为什么是2MSL？**

MSL是报文最大生存时间，等待2MSL一方面确保网络中所有数据包都被丢弃，不会保留到下一次连接。另一方面，**如果被动关闭方没有收到主动关闭方的ACK确认进行而超时重传，那么从主动关闭方发送ack到被动关闭方进行超时重传这样一来一回最多就是2MSL。**



**`注意ack不会重传，重传的是FIN请求。`**

## TCP与UDP的概念，特点，区别和对应的使⽤场景？

#### tcp/udp概念

tcp：(传输控制协议)，是一种面向连接的、可靠的、基于字节流的传输层通信协议

udp:（⽤户数据报协议）为应⽤程序提供了⼀种⽆需建⽴连接就可以发送封装的IP数据包的⽅
法。

#### 两者特点和区别

tcp：面向连接、传输可靠、效率低

udp：无连接、传输不可靠、效率高

##### **连接**

tcp传输数据需要先建立连接，udp不需要

##### 可靠性

tcp是可靠交付，保证数据无差错、不丢失、按序、不重复到达。

udp是尽最大努力交付，不保证可靠传输。

##### 服务对象

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

##### 拥塞控制和流量控制

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

##### 传输形式

tcp面向字节流，而udp面向报文

##### 首部开销

tcp首部开销更小（20-60字节），udp(8字节)

#### 使用场景

tcp：网页浏览、文件传输等

udp：广播通信、视频直播、实时游戏

## TCP流量控制、拥塞控制



# 四、IP篇

## ARP协议工作原理



# 速记

## 从输⼊ URL 到页面展示到底发⽣了什么？

查缓存，DNS解析，TCP连接，构造请求报文，请求并获取响应，解析响应

## 三次握手过程，为什么是三次握手？

同步序列号以及确认双发的收发能力，阻止旧的历史连接以及避免资源浪费

## 四次挥手过程，为什么需要四次？
