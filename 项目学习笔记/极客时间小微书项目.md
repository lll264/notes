![image-20240827151705527](assets/image-20240827151705527.png)

# 学习记录

## 登录功能

### 正则表达式校验参数

我们不要用golang自带的正则表达式而是导包

```go
"github.com/dlclark/regexp2"
```

正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。正则表达式可以在文本中查找、替换、提取和验证特定的模式。我的建议是不用学，要用的时候直接搜别人写好的。

**案例**

```go
const (
		emailRegexPattern = "^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$"
		// 和上面比起来，用 ` 看起来就比较清爽
		passwordRegexPattern = `^(?=.*[A-Za-z])(?=.*\d)(?=.*[$@$!%*#?&])[A-Za-z\d$@$!%*#?&]{8,}$`
	)
var emailExp    *regexp2.Regexp //邮箱校验器
var passwordExp *regexp2.Regexp //密码校验器
emailExp = regexp2.MustCompile(emailRegexPattern, regexp2.None)
passwordExp = regexp2.MustCompile(passwordRegexPattern, regexp2.None),
//校验	
ok, _ := emailExp.MatchString(req.Email)
if !ok {
    ctx.String(http.StatusOK, "你的邮箱格式不对")
}
ok, _ = passwordExp.MatchString(req.Password)
if !ok {
    ctx.String(http.StatusOK, "密码必须大于8位，包含数字、字母、特殊字符")
    return
}
```

### 跨域问题

跨域（Cross-Origin）指的是浏览器阻止前端网页从一个域名（Origin）向另一个域名的服务器发送请求。具体来说，一个页面的协议、域名、端口三者任意一个与请求的目标地址不同，就被视为跨域请求。

举例说明：

http://example.com 请求 http://api.example.com 会跨域，因为域名不同。
http://example.com 请求 https://example.com 会跨域，因为协议不同。
http://example.com:8080 请求 http://example.com:9090 会跨域，因为端口不同。

### 使用中间件解决

使用 middleware 来解决 CORS 目前大多数的 Web 框架，都提供了 CORS 的解决方案。

Gin 里面也提供了一个 middleware 实现来解决跨域问题，在 `github.com/gin-contrib/cors`

```go
r.Use(cors.New(cors.Config{
		//允许跨域访问的客户端地址，*表示所有都允许
		//AllowOrigins: []string{"*"},
		//允许跨域访问的方法，默认都有
		//AllowMethods:     []string{"PUT", "PATCH"},
		//允许客户端使用的请求头
		AllowHeaders: []string{"Content-type", "Authorization"},
		//允许带cookie之类的用户认证信息
		AllowCredentials: true,
		//使用方法校验忽略掉AllowOrigins
		AllowOriginFunc: func(origin string) bool {
			//你的开发环境，包含localhost就允许访问
			if strings.Contains(origin, "localhost") {
				return true
			}
			return strings.Contains(origin, "yourcompany.com")
		},
		MaxAge: 12 * time.Hour,
	}))
```

• AllowCrendentials：是否允许带上用户认证
信息（比如 cookie）。
• AllowHeader：业务请求中可以带上的头。
• AllowOriginFunc：哪些来源是允许的。

### 安装nodeJs运行前端

安装nodejs使用功能npm run dev运行前端在localhost:3000

### docker容器编排

在windows下安装docker desktop，安装安装portanier（可视化的Docker操作页面），使用docker容器编排功能运行mysql、redis环境

### **引入Service - Repostiory - DAO三层结构**

- service: 代表的是领域服务（domain service），代表一个业务的完整的处理过程。
- repository：按照 DDD 的说法，是代表领域对象的存储，这里你直观理解为存储数据的抽象。不仅仅代表数据库
- dao: 代表的是数据库操作。
- domain: 代表领域对象

### **BCrypt加密**

### **传导错误与检测**

在 repository 和 service 层，我们都使用别名机制，继续向上返回错误。在最顶层的 Handler 里面，我们进行检测。在确定是 ErrUserDuplicateEmail 的情况下，提示邮箱冲突了。使用别名的机制，层层传导，让我们在Handler 里面依旧保持只依赖 service，避免了`跨层依赖`的问题。

```go
var ErrUserDuplicateEmail = errors.New("邮箱冲突")
var ErrUserDuplicateEmail = dao.ErrUserDuplicateEmail
var ErrUserDuplicateEmail = repository.ErrUserDuplicateEmail
```

这样相比于定义一个err文件，并统一调用层次和扩展性更好

**使用errors.Is()方法与gorm内置错误类型比较判断err的具体类型**

```go
err := dao.db.WithContext(ctx).Where("email = ?", email).First(&u).Error
if errors.Is(err, gorm.ErrRecordNotFound) {
   return u, ErrUserNotFound
}
```

**注意**

不管是用户没找到，还是密码错误，我们都返回同一个 error。不能让前端知道具体哪错了

### cookie和session

#### 简介

HTTP 是无状态的。连续发两次请求，HTTP 并不知道这两个都是你发的。也就是，它没办法将上一次请求和这一次请求关联起来。所以我们需要有一种机制，记录一下这个状态。于是就有两个东西：Cookie 和 Session。

**Cookie**

浏览器存储一些数据到本地，这些数据就是Cookie。简单理解，就是存储在你电脑上的键值对。也正因为 Cookie 是放在浏览器本地的，所以很不安全。

**Session**

因为 Cookie 本身不安全的特性，所以大部分时候，我们都只在 Cookie 里面放一些不太关键的数据。关键数据我们希望放在后端，这个存储的东西就叫做 Session。因此在登录里面，我们就可以通过 Session 来记录登录状态。

第一次访问后，服务器要给浏览器一个 sess_id，也就是 Session 的ID。后续每一次请求都带上这个 Session ID，服务端就知道你是谁了。

因为 sess_id 是标识你身份的东西，所以你需要在每一次访问系统的时候都带上。

- 最佳方式就是用 Cookie，也就是 sess_id 放到 Cookie里面。sess_id 自身没有任何敏感信息，所以放 Cookie也可以。
- 也可以考虑放 Header，比如说在 Header 里面带一个sess_id。这就需要前端的研发记得在 Header里面带上。
- 还可以考虑放查询参数，也就是 ?sess_id = xxx。

#### 基于cookie的实现

使用中间件帮助创建session，校验session

```go
//使用session校验用户是否登录
//创建session
store := cookie.NewStore([]byte("secret"))
r.Use(sessions.Sessions("mysession", store))
//校验
r.Use(middleware.NewLoginMiddlewareBuilder().Build())
```

在登录成功后设置一个session

```go
//登录成功
//设置session的键值对为userId:user.Id
sess := sessions.Default(ctx)
sess.Set("userId", user.Id)
sess.Save()
ctx.String(http.StatusOK, "登录成功")
```

#### 基于redis的实现

redis好处在于分布式部署下的多个实例共享同一个session。但同时也会损耗性能。

通过 docker compose 来启动一个测试的 Redis。

```go
store, err := redis.NewStore(16, "tcp", "localhost:6379", "", []byte("secret"))
if err != nil {
   panic(err)
}
r.Use(sessions.Sessions("mysession", store))
//校验
r.Use(middleware.NewLoginMiddlewareBuilder().Build())
```

使用redis作为store存储session数据

`在 Gin 的 Session 设计里面，怎么存储你的 Session 数据，被抽象成了一个接口。`session的存储不但有redis,cookie还有memstore等等。

#### session参数

Gin 的 Session 有很多参数，你可以**通过 Options 方法来传入 Option**。可以理解为Gin 的 Session 用很多选项来初始化 Cookie。**比如设置session数据的过期时间**

```go
sess.Options(sessions.Options{
    //只允许https访问
    //secure: true,
   //60秒过期
   MaxAge: 60,
})
```

```go
// Logout 登出
func (u *UserHandler) Logout(ctx *gin.Context) {
   sess := sessions.Default(ctx)
   sess.Options(sessions.Options{
      //删除用户的cookie
      MaxAge: -1,
   })
   sess.Save()
   ctx.String(http.StatusOK, "退出登录成功")
}
```

#### 刷新登录状态

需要在用户持续使用网站的时候，刷新session过期时间。

##### 如何刷新

用户每次访问，我都刷新。性能差，对 Redis 之类的影响很大。

快要过期了我再刷新，比如说 10 分钟过期。当用户第 9 分钟访问过来的时候，我就刷新。万一我在第 9 分钟以后都没再访问过呢？

固定间隔时间刷新，比如说每分钟内第一次访问我都刷新。

使用长短 token。这个我们在后面接入微信登录的时候再深入讨论。

##### 在中间件中刷新

刷新可以在登录校验的中间件中完成，我们采用固定时间间隔刷新。在session中再设置一个update_time的数据，用户每次访问网站都会更新update_time为当前时间，并判断如果距离上次更新时间大于10s，就更新session过期时间进行刷新。

```go
updateTime := sess.Get("update_time")
//当前时间time.Time
now := time.Now()
//还没有刷新过刚登录
if updateTime == nil {
   sess.Set("update_time", now)
   sess.Save()
   return
}
updateTimeVal, _ := updateTime.(time.Time)
if now.Sub(updateTimeVal) > time.Second*10 {
   sess.Set("update_time", now)
   sess.Options(sessions.Options{
   	MaxAge: 60,
	})
   sess.Save()
   return
}
```

**使用redis的话每次访问都会去访问redis或取update_time，在高并发环境下是不行的。**

### JWT

#### 简介

前面我们实现的登录功能，是直接依赖于 Gin 的Session 插件达成的。我们还可以考虑使用 JWT 来实现登录功能。JWT（JSON Web Token）是很常用的一种机制，主要用于身份认证，也就是登录。它的基本原理就是通过加密生成一个 token，而后客户端每次访问的时候都带上这个 token。

它由三部分组成：
• Header：头部，JWT 的元数据，也就是描述这个token 本身的数据，一个 JSON 对象。
• Payload：负载，数据内容，一个 JSON 对象。
• Signature：签名，根据 header 和 token 生成。

#### 使用

直接使用 JWT 原始 API。

```go
go get github.com/golang-jwt/jwt/v5
```

##### 在midderware中定义生成token所需Claims，

```go
type UserClaims struct {
   jwt.RegisteredClaims
   //声明你自己的要放进去token里面的数据
   Uid int64
}
```

##### 登录成功后创建token，将tokenStr返回给前端

```go
//用jwt设置登录状态
//创建token
claims := middleware.UserClaims{
		RegisteredClaims: jwt.RegisteredClaims{
			//设置过期时间
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Minute)),
		},
		Uid: user.Id,
}
token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
tokenStr, err := token.SignedString([]byte("secret"))
if err != nil {
	ctx.String(http.StatusInternalServerError, "系统错误")
	return
}
//将token放到header中
ctx.Header("x-jwt-token", tokenStr)
//fmt.Println(tokenStr)
ctx.String(http.StatusOK, "登录成功")
```

##### 将登录校验从session改为jwt

```go
// Build 登录校验或者刷新登录状态
func (l *LoginJWTMiddlewareBuilder) Build() gin.HandlerFunc {
	//用go的方式编码解码
	gob.Register(time.Now())
	return func(ctx *gin.Context) {
		//登录和注册不需要校验
		for _, path := range l.paths {
			if ctx.Request.URL.Path == path {
				return
			}
		}
		//Bearer xxx.xxx.xxx
		tokenHeader := ctx.GetHeader("Authorization")
		if tokenHeader == "" {
			//没登录
			ctx.AbortWithStatus(http.StatusUnauthorized)
			return
		}
		segs := strings.Split(tokenHeader, " ")
		if len(segs) != 2 {
			//格式不对，没登录
			ctx.AbortWithStatus(http.StatusUnauthorized)
			return
		}
		tokenStr := segs[1]
		//解析时传指针
		claims := &UserClaims{}
		token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) {
			return []byte("secret"), nil
		})
		if err != nil {
			//没登录
			ctx.AbortWithStatus(http.StatusUnauthorized)
			return
		}
		//token无效
		if token == nil || !token.Valid || claims.Uid == 0 {
			//没登录
			ctx.AbortWithStatus(http.StatusUnauthorized)
			return
		}
        //每10s刷新一次，token过期时间
		now := time.Now()
		if claims.ExpiresAt.Sub(now) < time.Second*50 {
			claims.ExpiresAt = jwt.NewNumericDate(time.Now().Add(time.Minute))
			tokenStr, err = token.SignedString([]byte("secret"))
			if err != nil {
				log.Println("jwt 续约失败")
				return
			}
			ctx.Header("x-jwt-token", tokenStr)
		}
		ctx.Set("claims", claims)
	}
}
```

#### JWT 改造跨域设置

后端将token放在响应头中前端接收不到，是因为跨域设置中要设置ExposeHeaders ：[]strings{"x-jwt-token"}

请求报文要带上Authorization，因此跨域设置中要AllowHeaders加上Authorization

#### 用布隆过滤器实现退出登录

#### 接入 JWT 的步骤总结

• 要在 Login 接口中，登录成功后生成 JWT token。

• 在 JWT token 中写入数据。

• 把 JWT token 通过 HTTP Response Header x-jwt-token 返回。

• 改造跨域中间，允许前端访问 x-jwt-token 这个响应头。

• 要接入 JWT 登录校验的 Gin middleware。

• 读取 JWT token。

• 验证 JWT token 是否合法。

• 前端要携带 JWT token。

#### 使用 JWT 的优缺点

和 Session 比起来，优点：

• 不依赖于第三方存储。

• 适合在分布式环境下使用。

• 提高性能（因为没有 Redis 访问之类的）。

缺点：

• 对加密依赖非常大，比 Session 容易泄密。

• 最好不要在 JWT 里面放置敏感信息。

#### 保护系统

##### 限流（无需掌握）

限流是最常见的保护系统的办法。限流有很多算法，但是都大同小异，后面在微服务架构部分会进一步讲解。这里我们使用限流，限制每一个用户，每秒最多发送固定数量的请求。所以问题来了：

• 我怎么认定谁是谁？尤其是在登录和注册这个接口里，都还没登录成功，我都不知道他是谁。

• 我怎么确定我限流的这个阈值应该是多少？每秒 100 还是每秒 200？

**限流对象**

**限流阈值**

**被限流的请求直接返回错误**

**使用gin的限流插件**



##### jwt增强登录安全

利用 User-Agent 增强安全性,为此需要改造两个地方：

• Login 接口，在 JWT token 里面带上 User-Agent信息。

```go
claims := middleware.UserClaims{
   RegisteredClaims: jwt.RegisteredClaims{
      //设置过期时间
      ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Minute)),
   },
   UserAgent: ctx.Request.UserAgent(),
   Uid:       user.Id,
}
```

• JWT 登录校验中间件，在里面比较 User-Agent。

```go
//增强登录安全，校验UserAgent
if claims.UserAgent != ctx.Request.UserAgent() {
   ctx.AbortWithStatus(http.StatusUnauthorized)
   return
}
```

### 性能测试与优化

#### 利用 wrk 来压测接口

我们可以考虑使用 wrk 先来压测接口。我们压测三个接口：

• 注册：写为主的接口
• 登录：读为主的接口
• Profile：读为主的接口

wrk 这个工具前期不要求你掌握，只需要把我这里运行的命令贴到命令行跑起来就可以。

##### **安装**

```bash
3.2、在Ubuntu子系统安装wrk

# 进入Ubuntu子系统
wsl -d Ubuntu

# 安装wrk
sudo apt-get install -y wrk
复制
3.3、安装验证

wrk -v
```

##### 编写lua脚本（后面学）

##### 在lua脚本目录下执行命令

`wrk -t1 -d1s -c2 -s ./scripts/wrk/signup.lua http://localhost:8080/users/signup`

注意，你可以不断调整这些参数：

**• -t：后面跟着的是线程数量。**

**• -d：后面跟着的是持续时间，比如说 1s 是一秒，**

**也可以是 1m，是一分钟。**

**• -c：后面跟着的是并发数。**

**• -s：后面跟着的是测试的脚本。**

最终能跑多少，和你机器有关。

![image-20240907165659707](assets/image-20240907165659707.png)

#### 使用redis缓存优化性能

以上完成的功能中基本上性能瓶颈是出在数据库的查询上，所以我们可以考虑引入 Redis 来优化性能。用户会先从 Redis 里面查询，而后在缓存未命中的情况下，就会直接从数据库中查询。

##### 代码解释

查询有两种写法：

- 只要缓存返回了 error，不管有没有查找到或有没有出错，直接去数据库查询，**有隐患的。那就是万一 Redis 本身崩溃了，那么查询都会落到数据库上。**
- 只有缓存没查找到数据才去数据库查询。**代价就是 Redis 崩溃之后，业务也不可用，但是数**
  **据库保住了。**

##### 登录要不要缓存

**可以，但是收益不大。**

因为登录是一个非常低频的事情，正常的互联网网站都是好几天才会让你登录一次，你缓存了也没用。

## k8s部署

### Kubernetes入门

• Pod：实例。运行的容器

• Service：逻辑上的服务，可以认为这个是你业务上 XXX 服务的直接映射。

• Deployment：管理 Pod 的东西。

。。。。。

#### 开启docker desktop的enable kubernetes

docker desktop使用kubenetes国内安装不了，https://github.com/AliyunContainerService/k8s-for-docker-desktop/tree/v1.30.2查看教程下载

下载上面的zip文件解压后，在powershell中执行.\load_images.ps1，等待安装完成后，退出Docker Desktop，删除c盘用户目录下/.kube/config文件，然后再运行Docker Desktop

下载10个镜像文件

```bash
hubproxy.docker.internal:5555/docker/desktop-kubernetes                                      kubernetes-v1.27.2-cni-v1.2.0-critools-v1.27.0-cri-dockerd-v0.3.2-1-debian   c763812a4530   2 months ago   418MB
registry.k8s.io/kube-apiserver                                                               v1.27.2                                                                      c5b13e4f7806   2 months ago   121MB
registry.k8s.io/kube-scheduler                                                               v1.27.2                                                                      89e70da428d2   2 months ago   58.4MB
registry.k8s.io/kube-controller-manager                                                      v1.27.2                                                                      ac2b7465ebba   2 months ago   112MB
registry.k8s.io/kube-proxy                                                                   v1.27.2                                                                      b8aa50768fd6   2 months ago   71.1MB
docker/desktop-vpnkit-controller                                                             dc331cb22850be0cdd97c84a9cfecaf44a1afb6e                                     556098075b3d   2 months ago   36.2MB
registry.k8s.io/coredns/coredns                                                              v1.10.1                                                                      ead0a4a53df8   6 months ago   53.6MB
registry.k8s.io/etcd                                                                         3.5.7-0                                                                      86b6af7dd652   6 months ago   296MB
registry.k8s.io/pause                                                                        3.9                                                                          e6f181688397   9 months ago   744kB
docker/desktop-storage-provisioner
```

#### kubectl

**后就要安装kubectl工具了

##### 安装（科学上网）

```
cul 。。。
```

##### 指令

kubectl get pods/deployment/service 查看实例/管理/服务

kubectl logs webook-2343h234-qwe24 查看具体实例信息

### 部署web服务

#### 准备Kubernetes容器镜像

因为k8s调度的是容器，所有先要把 webook 打包成镜像。

• 首先在本地完成编译，生成一个可在 Linux 平台上执行的 webook 可执行文件。基本命令是：GOOS=linux GOARCH=arm go build -o webook .

**windows下先set GOOS=linux和set GOARCH=arm然后go build -o webook**

• 其次是编写Dockerfile文件运行 Docker 命令，**docker build -t flycash/webook:v0.0.1 .**打包成一个镜像。

出于方便的目的，**使用make工具编写Makefile文件，打包成了一个 make docker 命令**。

```makefile
.PHONY: docker
docker:
   @del webook || true
   @set GOOS=linux
   @set GOARCH=amd64
   @go build -o webook
   @set GOOS=windows
   @docker rmi -f flycash/webook:v0.0.1
   @docker build -t flycash/webook:v0.0.1 .
```

#### 编写Deployment

k8s-webook-deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webook
spec:
  #副本数量
  replicas: 3
  selector:
    matchLabels:
      app: webook
  #template描述的是你的POD是什么样的
  template:
    metadata:
      labels:
        app: webook
    #POD的具体信息
    spec:
      containers:
        - name: webook
          image: flycash/webook:v0.0.1
          ports:
            - containerPort: 8080
```

使用`kubectl apply -f k8s-webook-deployment.yaml`应用配置

```bash
D:\Go\project\src\geektime\webook>kubectl get deployment
NAME     READY   UP-TO-DATE   AVAILABLE   AGE
webook   3/3     3            3           3h51m
```



##### apiVersion

K8s 简单理解就是一个配置驱动的，或者元数据驱动，或者声明式的框架。怎么理解这句话？

我们用户只负责提供各种配置，然后 K8s 根据配置来执行一些动作。所以问题就来了，K8s 怎么知道该怎么解读这个配置呢？答案就是利用 apiVersion 来确定怎么解读。

##### spec

spec(specification)，也就是 Deployment 的规格说明，规格说明你就直接理解为说明书：

• **replicas**：值为 3，也就是我这个 Deployment 有三个副本，实际上就是三个 Pod。

• **selector**：筛选器，就是在 K8s 的一大堆 Pod 里面，我怎么知道哪些是我管理的那三个。

• **template**：我该怎么创建每个 Pod，或者说每个Pod 长什么样。有了 template（模板），我就可以照猫画虎直接创建出来了。

##### selector

筛选器，它在 K8s 里面被用来筛选所需资源。我们配置 selector 使用的是matchLabels。也就是说，Deployment 按照标签（label）来筛选它需要的资源——Pod。它需要的是含有 app=webook 这个标签的 Pod。

常用的除了 matchLabels 还有 matchExpressions，即根据表达式来筛选。

##### template

emplate 在 kind 不同的时候对应的内容也不同。在 Deployment 里面，template 是**创建 Pod 的模**
**板。**

##### iamge

image 就是镜像，显然这里我们用的是 Docker 构建的镜像。

#### 编写Service

k8s-webook-service.yaml

```yaml
apiVersion: v1
kind: Service
metadata:
  name: webook
#规格说明，这是一个怎样的服务
spec:
  type: LoadBalancer
  selector:
    app: webook
  ports:
    - name: http
      port: 81
      protocol: TCP
      targetPort: 8080
```

只有 Deployment 你是没办法从外面访问的，你需要**将 Pod 封装为一个逻辑上的服务，即Service。**

spec 里面有两个字段要注意：

• type：这里选择的是负载均衡，意思是这个 Service 在逻辑上还要负责负载均衡的问题。给谁负载均衡？给 selector 里面筛选出来的 Pod 做负载均衡。

• ports：端口，你可以配置很多个，比如还可以额外配置一个 HTTPS 的。

• name：就是你这个端口的名字，一般用来指示用途，比如http 意思是这个端口用来接收 HTTP 请求。你可以随便写。

• port：外部访问的端口。

• protocol：这个端口监听什么协议。

• targetPort：我这边转发请求的时候，应该转发到 Pod 上的哪个端口。

#### 启动

`使用kubectl apply -f k8s-webook-service.yaml命令应用配置启动服务，就可以访问了`

```bash
D:\Go\project\src\geektime\webook>kubectl get service                         
NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
kubernetes   ClusterIP      10.96.0.1       <none>        443/TCP        3h28m
webook       LoadBalancer   10.102.65.255   localhost     81:30481/TCP   118m
```

### 部署MySQL

![mysql_deploy](assets/mysql_deploy.png)

部署方式与部署web服务类似，不过MySQL 和前面的 Go 应用不一样，它需要存储数据，也就是我们要给它一个存储空间。`在 K8s 里面，存储空间被抽象为 PersistentVolume（持久化卷）`

#### deployment

在 template 里面，关键是**spec.containers.volumeMounts 和 volumes。**

• 在 containers 里面的 volumeMounts，意思是挂载到我容器的哪个地方。

• volumns 是指，我这里挂载的东西究竟是什么。

k8s-mysql-deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webook-mysql
spec:
  replicas: 1
  #筛选
  selector:
    matchLabels:
      app: webook-mysql
  #模板
  template:
    metadata:
      name: webook-mysql
      labels:
        app: webook-mysql
    spec:
      containers:
        - name: webook-mysql
          image: mysql:8
          imagePullPolicy: IfNotPresent
          env:
            - name: MYSQL_ROOT_PASSWORD
              value: root
          volumeMounts:
#            这边要对应到mysql的数据存储的位置
            - mountPath: /var/lib/mysql
              #指定使用的volume
              name: mysql-storage
          ports:
            - containerPort: 3306
      restartPolicy: Always
      #整个pod拥有的volume
      volumes:
        #持久化卷可以有多个
        - name: mysql-storage
          persistentVolumeClaim:
            claimName: webook-mysql-claim
#        - name: hadoop-storage
#          persistentVolumeClaim:
#            claimName: webook-hadoop-claim
```



#### service

k8s-mysql-service.yaml

```yaml
apiVersion: v1
kind: Service
metadata:
  name: webook-mysql
spec:
  #筛选 app:webook-mysql的pod
  selector:
    app: webook-mysql
  ports:
    #避免冲突，使用11309端口，这里使用了nodePort所以是30002端口
    - port: 11309
      name: mysql
      protocol: TCP
      targetPort: 3306
      nodePort: 30002
  type: NodePort
```

#### PersistentVolumeClaim

一个容器需要什么存储资源，是通过PersistentVolumeClaim 来声明的。

k8s-mysql-pvc.yaml

```yaml
apiVersion: v1
#声明需要什么样的volume
kind: PersistentVolumeClaim
metadata:
  name: webook-mysql-claim
  labels:
    app: webook-mysql-claim
spec:
  storageClassName: suibian
  #需要的读写方式
  accessModes:
    #一个POD读写
    - ReadWriteOnce
#    #多个读，一个写
#    - ReadOnlyMany
#    #多个读写
#    - ReadWriteMany
  resources:
    requests:
      #1GB = 1Gi
      storage: 1Gi
```

#### PersistentVolume

持久化卷，表达我是一个什么样的存储结构。所以，PersistentVolume 是存储本身说我有什么特
性，而 PersistentVolumeClaim 是用的人告诉 K8s说他需要什么特性。

k8s-mysql-pv.yaml

```yaml
apiVersion: v1
#声明 k8s 有哪些 volume
kind: PersistentVolume
metadata:
  name: my-local-pv
  labels:
    app: my-local-pv
spec:
  storageClassName: suibian
  capacity:
    storage: 1Gi
  #支持的读写方式
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data"
```

#### 访问模式accessMode

如果你设计一个存储的东西，你是不是要考虑，我这个东西是只读还是只写？是允许一个人访问，还是允许很多人访问？这个东西，就是由 accessMode 来控制的。

**在 PersistentVolume 里面，accessMode 是说明我这个 PV 支持什么访问模式。**

**在 PersistentVolumeClaim 里面，accessMode 是说明我这个 PVC 需要怎么访问。**

• **ReadWriteOnce**：只能被挂在到一个 Pod，被它读写。

• **ReadOnlyMany**：可以被多个 Pod 挂载，但是只能读。

• **ReadWriteMany**：可以被多个 Pod 挂载，它们都能读写。

### 部署Redis

#### 允许外部访问

设置`sepc.type: NodePort和sepc.ports.nodePort: 外部端口`，直接通过外部访问

#### port、nodePort 和 targetPort 的含义

- **port**：kubernetes中的服务之间访问的端口，是提供给集群内部客户访问service的入口。尽管mysql容器暴露了3306端口，但是集群内其他容器需要通过33306服务端口访问该服务
- **targetPort**：是指 Pod 上暴露的端口，容器的端口（最根本的端口入口）。port和nodePort上到来的访问都要经过targetPort到达容器
- **nodePort**：是指我在 K8s 集群之外访问的端口，比如说我执行 redis-cli -p 30379。

**port和nodePort都是service的端口，前者暴露给集群内客户访问服务，后者暴露给集群外客户访问服务。**从这两个端口到来的数据都需要经过反向代理kube-proxy流入后端pod的targetPod，从而到达pod上的容器内。

![ports](assets/ports.png)

### 部署nginx（有问题待处理）

**安装helm**

**安装ingress-nginx**

**编写ingress**

### 集成Redis和MySQL

#### 编译标签

因为暂时还没有引入配置模块，所以我们现在用一种特别的方法来控制不同的参数。首先我们定义一个结构体，用来接收配置。而后我们在两个文件里面初始化这个配置，其中一个就是正常的文件，叫做 dev.go。另外一个就是k8s.go。两者唯一的区别就是在 k8s.go 里面需要指定一个叫做 k8s 的编译标签。

```go
type config struct {
   DB    DBConfig
   Redis RedisConfig
}

type DBConfig struct {
   DSN string
}

type RedisConfig struct {
   Addr string
}
```

k8s.go

```go
//go:build k8s
package config

var Config = config{
	DB: DBConfig{
		DSN: "root:root@tcp(webook-mysql:11309)/webook",
	},
	Redis: RedisConfig{
		Addr: "webook-redis:11479",
	},
}
```

dev.go

```go
//go:build !k8s
package config

var Config = config{
	DB: DBConfig{
		DSN: "root:root@tcp(localhost:13316)/webook",
	},
	Redis: RedisConfig{
		Addr: "localhost:6379",
	},
}
```

**编译的时候只要带上对应的标签，对应的文件就回参与编译**，比如只编译k8s文件

```bash
go build -tags=k8s -o webook .
```

!k8s只要没有带上k8s标签，那么就会编译这个文件

## 短信登录

### 需求分析

### 短信服务API

#### 基本步骤

首先是**初始化短信客户端，里面要求传入各种鉴权参数。其次是发送一条短信的请求构造，然后发送请求并接收响应**，里面传入的主要是短信本身相关的参数。关键的是：
• 目标手机号码
• 模板：要求你提前在服务商里面配置好，得到模板 ID。
• 参数：发送短信的时候的具体参数。
• appId：你在腾讯短信上创建的应用的 ID。
• 签名：要求发送的短信必须标记是谁发的。

其中 appId 和签名在我们小微书里面都是固定的，同样可以在初始化的时候指定，但是发送的时候就不用传递参数了。

#### 使用API发送短信

这里我使用官方的快速使用案例，为其中每一步做出解释

首先我们需要导入dysmsapi包

```go
go get github.com/aliyun/alibaba-cloud-sdk-go/services/dysmsapi
```

使用NewClientWithAccessKey()创建一个client客户端,这个客户端可以调用阿里云的API

```go
package main

import (
	"github.com/aliyun/alibaba-cloud-sdk-go/services/dysmsapi"
)

func main() {
    //参数一：连接的节点地址（有很多节点选择，这里我选择杭州）
    //参数二：AccessKey ID
    //参数三：AccessKey Secret
	client, err := dysmsapi.NewClientWithAccessKey("cn-hangzhou", "LTAI5t**********AWVNP", "qgzyEW4cA*******PBl7iyw")
｝
```

然后创建请求，并填写请求信息

```go
package main

import (
    "encoding/json"
	"github.com/aliyun/alibaba-cloud-sdk-go/services/dysmsapi"
)

func main() {
    //参数一：连接的节点地址（有很多节点选择，这里我选择杭州）
    //参数二：AccessKey ID
    //参数三：AccessKey Secret
	client, err := dysmsapi.NewClientWithAccessKey("cn-hangzhou", 	  "LTAI5t**********AWVNP", "qgzyEW4cA*******PBl7iyw")
	request := dysmsapi.CreateSendSmsRequest()       //创建请求
	request.Scheme = "https"                         //请求协议
	request.PhoneNumbers = "155******85"             //接收短信的手机号码
	request.SignName = "教程"                         //短信签名名称
	request.TemplateCode = "SMS_******236"           //短信模板ID
	par, err := json.Marshal(map[string]interface{}{ //定义短信模板参数（具体需要几个参数根据自己短信模板格式）
		"code": "123456",
	})
	request.TemplateParam = string(par)      //将短信模板参数传入短信模板
}
调用SendSms（）方法发送请求，并处理错误
```
调用SendSms（）方法发送请求，并处理错误

```go
package main

import (
    "encoding/json"
	"github.com/aliyun/alibaba-cloud-sdk-go/services/dysmsapi"
)

func main() {
    //参数一：连接的节点地址（有很多节点选择，这里我选择杭州）
    //参数二：AccessKey ID
    //参数三：AccessKey Secret
	client, err := dysmsapi.NewClientWithAccessKey("cn-hangzhou", 	"LTAI5t**********AWVNP", "qgzyEW4cA*******PBl7iyw")
	request := dysmsapi.CreateSendSmsRequest()       //创建请求
	request.Scheme = "https"                         //请求协议
	request.PhoneNumbers = "155******85"             //接收短信的手机号码
	request.SignName = "教程"                         //短信签名名称
	request.TemplateCode = "SMS_******236"           //短信模板ID
	par, err := json.Marshal(map[string]interface{}{ //定义短信模板参数（具体需要几个参数根据自己短信模板格式）
		"code": "123456",
	})
	request.TemplateParam = string(par)      //将短信模板参数传入短信模板
 
	response, err := client.SendSms(request) //调用阿里云API发送信息
	if err != nil {                          //处理错误
		fmt.Print(err.Error())
	}
	fmt.Printf("response is %#v\n", response) //控制台输出响应
}
```
#### 测试

```go
client, err := dysmsapi.NewClientWithAccessKey("cn-hangzhou",
   "LTAI5t5Zg34ubpUzEmUoT5at",
   "lzKeLpayDR7Brh35jSdSGXxSCHd9LC")

request := dysmsapi.CreateSendSmsRequest()       //创建请求
request.Scheme = "https"                         //请求协议
request.PhoneNumbers = "18873288626"             //接收短信的手机号码
request.SignName = "小微书"                         //短信签名名称
request.TemplateCode = "SMS_472665076"           //短信模板ID
par, err := json.Marshal(map[string]interface{}{ //定义短信模板参数（具体需要几个参数根据自己短信模板格式）
   "code": "123456",
})
request.TemplateParam = string(par)      //将短信模板参数传入短信模板
response, err := client.SendSms(request) //调用阿里云API发送信息
if err != nil {                          //处理错误
   fmt.Print(err.Error())
}
fmt.Printf("response is %#v\n", response) //控制台输出响应
```

### 验证码服务

#### 安全问题

**控制住验证码发送频率，不至于一下子发送几百万条。**

• 同一个手机号码，一分钟以内只能发送一次。
• 验证码有效期十分钟。
• 本身整个系统也有限流，也可以保护住系统。

**验证码不能被攻击者暴力破解，因为验证码只有 6 位，也就是只有十万种可能，所以不能让用户频繁输入验证码来暴力破解。**

• 一个验证码，如果已经验证通过了，那么就不能再用。
• 一个验证码，如果已经三次验证失败，那么这个验证码就不再可用。在这种情况下，只会告
诉用户输入的验证码不对，但是不会提示验证码过于频繁失败问题。

#### 功能分析

- 前端输入手机号码点击获取验证码后向后端发送请求
- 后端生成一个6位随机数作为验证码，先将其存入redis中
- **存入redis**时，key为`biz(用途):phone`，val为验证码。首先获取biz:phone的过期时间
  - 如果key存在，但没有过期时间，表明系统错误
  - 如果key存在且过期时间表明已经过了1分钟 或者 key不存在，那么可以存入并**设置过期时间为10分钟，set(cntKey, 3)表示可验证的次数为3**
  - 如果key存在且时间没过1分钟，发送太频繁，不能存入
- 如果后端验证码存入成功后，就调用手机短信服务将验证码发送给对应手机用户
- 用户在填写验证码后点击确认，**后端进行校验**
  - 如果get(cntKey) <=0 即校验次数用完了，验证码校验次数用完
  - 或者验证码与redis中的不符即用户输错
  - 验证成功，set(cntKey, -1), 该验证码不可用

#### 并发问题

假如多个线程同时查询验证码，这些线程都没查到验证码，就都会写入，就有并发问题

##### 解决方法

分布式锁（不推荐）

**参考**：redis结合lua脚本解决多线程并发安全问题：https://blog.csdn.net/incredible1024/article/details/130093799

我们要考虑的就是在 Redis 层面上实现。利用 lua 脚本将我们的检查并且做某事的逻辑封装成一个整体操作。为什么 Redis 是安全的？因为 Redis 是单线程的。

**不同线程的 lua 脚本是依次执行的**。也就是说，**只有一个线程原子性的多个操作执行完，下一个线程才可以执行**。实际上也是保证了在 redis 内部不同线程操作的串行执行，从而能够解决并发安全问题。

<img src="assets/image-20240908172153926.png" alt="image-20240908172153926" style="zoom: 25%;" />

### 短信验证码登录

#### 验证码登录接口

整体来说，我们需要两个 HTTP 接口：

**• 触发发送验证码的接口。**
**• 校验验证码的接口。**

我都定义到了 UserHandler 里面。也就是 UserHandler 通过聚合 CodeService来实现验证码登录。

**如图**

<img src="assets/image-20240909083034969.png" alt="image-20240909083034969" style="zoom: 25%;" />

#### 发送验证码核心代码

```go
err := u.codeSvc.Send(ctx, "login", req.Phone)
if err != nil {
   if err == service.ErrCodeSendTooMany {
      ctx.JSON(http.StatusOK, Result{
         Code: 5,
         Msg:  "发送太频繁",
      })
   } else if err == service.ErrCodeVerifyTooMany {
      ctx.JSON(http.StatusOK, Result{
         Code: 5,
         Msg:  "验证太频繁",
      })
   } else {
      ctx.JSON(http.StatusOK, Result{
         Code: 5,
         Msg:  "系统错误",
      })
   }
   return
}
ctx.JSON(http.StatusOK, Result{
   Code: 5,
   Msg:  "发送成功",
})
```

#### 校验验证码核心

```go
//通过正则表达式判断是否是一个合法的电话号码
ok, _ := u.phoneExp.MatchString(req.Phone)
if !ok {
   ctx.JSON(http.StatusOK, Result{
      Code: 4,
      Msg:  "输入有误",
   })
}
//这里也可以先初步校验一下验证码
ok, err := u.codeSvc.Verify(ctx, "login", req.Phone, req.Code)
if err != nil {
   ctx.JSON(http.StatusOK, Result{
      Code: 5,
      Msg:  "系统错误",
   })
   return
}
if !ok {
   ctx.JSON(http.StatusOK, Result{
      Code: 4,
      Msg:  "验证有误",
   })
   return
}
ctx.JSON(http.StatusOK, Result{
   Code: 4,
   Msg:  "验证码校验成功",
})
```

#### 实现登录核心

##### FindOrCreate

从数据库中根据phone查找用户，如果user不存在就创建进行注册，存在就返回。

也可以不查找，直接insert用phone注册用户，这样如果发生了phone冲突，那么就表明用户存在直接返回

```go
func (svc *UserService) FindOrCreate(ctx *gin.Context, phone string) (domain.User, error) {
   //这个叫快路径，数据库中找到了就不用去创建了
   //快路径可以不执行，直接执行慢路径，直接去创建，冲突则创建失败
   u, err := svc.repo.FindByPhone(ctx, phone)
   //找到了 或者 报错
   if err != repository.ErrUserNotFound {
      return u, err
   }
   /* //在系统资源不足，触发降级之后，不执行慢路径了
      if ctx.Value("降级") == "true" {
         return domain.User{}, errors.New("系统降级了")
      }*/
   //这个叫慢路径
   //没有找到，就用手机号码注册一个新用户
   err = svc.repo.Create(ctx, domain.User{
      Phone: phone,
   })
   //手机号冲突就说明用户存在
   if err != nil && err != ErrUserDuplicate {
      return domain.User{}, err
   }
   //查找新创建的或已存在的用户，获取id
   return svc.repo.FindByPhone(ctx, phone)
}
```

登录或注册成功后，同样设置jwt-token

##### 唯一索引问题

phone和email都是唯一索引，而当分别使用email和phone注册账号后，对应账号的phone和email分别为空，因为唯一索引不能有多个空值，**所以手机号和邮箱设置为`sql.NullString`，表示可以为空**

```go
type NullString struct {
   String string
   Valid  bool // Valid is true if String is not NULL
}
```

```go
// User 直接对应数据库表结构，这个User是存储时候的User
type User struct {
   Id int64 `gorm:"primaryKey, autoIncrement"`
   //邮箱，用户唯一但可以为空
   Email    sql.NullString `gorm:"unique"`
   Password string
   //手机号，用户唯一但可以为空
   Phone sql.NullString `gorm:"unique"`
   //创建时间，毫秒
   Ctime int64
   //更新时间，毫秒
   Utime int64
}
```

##### 扩展

之所以我们可以用 sql.NullString，是因为它实现了两个接口：sql.Scanner 和 driver.Valuer。

![db123](assets/db123.png)

### 依赖注入

你仔细看我们的初始化代码，就会发现整体来说可以分成几个步骤：
• 初始化第三方依赖，也就是 DB、Redis 等。
• 用 DB、Redis 等来初始化 DAO、Cache。
• 用 DAO、Cache 初始化 Repository。
• 用 Repository 初始化 Service。
• 用 Service 初始化 Handler。
• 初始化 Gin，注册路由。
• 初始化结束。

整个过程就是层层组装，也是标准的依赖注入写法。所谓的依赖注入，是指 A 依赖于 B，也就是 A 要调用 B 上的方法，那么 A 在初始化的时候就要求传入一个构建好的 B。

**依赖注入写法**：不关心依赖是如何构造的。

**非依赖注入写法**：必须自己初始化依赖，比如说 Repository 需要知道如何初始化 DAO 和 Cache。由此带来的缺点是：

• 深度耦合依赖的初始化过程。
• 往往需要定义额外的 Config 类型来传递依赖所需的配置信息。
• 一旦依赖增加新的配置，或者更改了初始化过程，都要跟着修改。
• 缺乏扩展性。
• 测试不友好。
• 难以复用公共组件，例如 DB 或 Redis 之类的客户端。

#### Wire

依赖注入的缺点就是要在系统初始化的过程中（main函数），完成复杂冗长的构造链表。所以我们可以借助一些中间件来帮助我们完成这些复杂又没有多少技术含量的事情。在 Go 里面，我推荐使用 wire。wire 分成两部分，**一个是在项目中使用的依赖，一个是命令行工具。**

**安装 Wire**

```bash
go install github.com/google/wire/cmd/wire@latest
```

**项目依赖**

```go
"github.com/google/wire"
```

**简单示例**

wire 使用有两个基本步骤：

• 往 wire 里面注册各种初始化方法。
• 运行 `wire` 命令。

```go
//go:build wireinject

package wire

import (
   "geektime/wire/repository"
   "geektime/wire/repository/dao"
   "github.com/google/wire"
)

func InitUserRepository() *repository.UserRepository {
   wire.Build(repository.NewUserRepository, InitDB, dao.NewUserDAO)
   return new(repository.UserRepository)
}

func InitDB() *gorm.DB {
   db, err := gorm.Open(mysql.Open("xxx"))
   if err != nil {
      panic(err)
   }
   return db
}
```

```go
type UserDAO struct {
	db *gorm.DB
}

func NewUserDAO(db *gorm.DB) *UserDAO {
	return &UserDAO{
		db: db,
	}
}
```

```go
type UserRepository struct {
   dao *dao.UserDAO
}

func NewUserRepository(d *dao.UserDAO) *UserRepository {
   return &UserRepository{
      dao: d,
   }
}
```

在wire文件目录执行wire命令即可，自动生成如下文件wire_gen，调用这个方法即可

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"geektime/wire/repository"
	"geektime/wire/repository/dao"
)
// Injectors from wire.go:
func InitUserRepository() *repository.UserRepository {
	db := InitDB()
	userDAO := dao.NewUserDAO(db)
	userRepository := repository.NewUserRepository(userDAO)
	return userRepository
}
```

#### 组装核心代码

```go
//go:build wireinject

package main

import (
   "geektime/webook/internal/repository"
   "geektime/webook/internal/repository/cache"
   "geektime/webook/internal/repository/dao"
   "geektime/webook/internal/service"
   "geektime/webook/internal/web"
   "geektime/webook/ioc"
   "github.com/gin-gonic/gin"
   "github.com/google/wire"
)

func InitWebServer() *gin.Engine {
   wire.Build(
      //第三方依赖
      ioc.InitDB, ioc.InitRedis,
      //dao
      dao.NewUserDao,
      //cache
      cache.NewUserCache, cache.NewCodeCache,
      //repository
      repository.NewUserRepository, repository.NewCodeRepository,
      //service
      ioc.InitSMSService,
      service.NewCodeService, service.NewUserService,
      //handler
      web.NewUserHandler,
      ioc.InitMiddlewares,
      ioc.InitWebServer,
   )
   return new(gin.Engine)
}
```

#### wire缺点

 wire 的缺点：

• 缺乏根据环境使用不同实现的能力。
• 缺乏根据接口查找实现的能力。
• 缺乏根据类型查找所有实例的能力。

这也就导致我们的依赖注入的代码，始终做不到非常清爽。一句话，wire 也就是矮个子里面挑高个。wire 最大的好处就是很清晰，可控性非常强。

#### IoC：控制反转

**依赖注入是控制反转的一种实现形式**。还有一种叫做**依赖发现。比如说 A 调用 B，然后 A 自己去**
**找到可用的 B，那就是依赖发现。**简单来说，如果 A 用 B 接口的时候，需要自己创建一个，
比如说 UserHandler 里面自己创建一个 UserService 的实现，那么 UserHandler 就和 UserService 的实现耦合在一起了。

**控制反转的意思就是，UserHandler 不会去初始化UserService。要么外面传入 UserService 给**
**UserHandler，这种叫做依赖注入；要么是 UserHandler自己去找一个 UserService，这种叫做依赖查找。**

### 面向接口编程

面向接口编程是指将应用程序定义为组件的集合，组件与组件之间的通信必须通过接口。简单来说，就是如果你要用到另外一个类型，那么你肯定用的是接口。比如说 A 调用 B 的时候，B 必须是一个接口。结合依赖注入，就是写代码的时候 A 调用 B，B 是一个接口。而后在初始化的时候，注入一个实现了 B 接口的实例。

#### 示例

CodeService 对 sms.Service 的用法就是面向接口编程。所以你可以注入不同的实现，比如说腾讯云的实现，或者基于内存的实现。**sms.Service是一个接口，sms可以是不同的实例，比如阿里云、腾讯、本地内存的实现。**

```go
type CodeService interface {
	// Send bix 区别业务场景，用于什么的验证码
	Send(ctx context.Context, biz, phone string) error
	Verify(ctx context.Context,
		biz, phone, inputCode string) (bool, error)
}

type codeService struct {
	repo repository.CodeRepository
	sms  sms.Service
}
```

#### 为什么要面向接口编程

![面向接口.drawio](assets/面向接口.drawio.png)

**为了扩展性**。但面向接口编程，能够有效让你的代码充满扩展性，正如 sms.Service，你可以随时提供一个基于内存的实现、基于腾讯的实现。

#### 现有代码改造

##### 改造dao

实现一个GORMUserDAO，后续可能使用sqlx，原生sql等等其他数据库的实现

```go
type UserDAO interface {
   Insert(ctx context.Context, u User) error
   FindByEmail(ctx context.Context, email string) (User, error)
   FindById(ctx context.Context, id int64) (User, error)
   FindByPhone(ctx *gin.Context, phone string) (User, error)
}

type GORMUserDAO struct {
   db *gorm.DB
}

func NewUserDao(db *gorm.DB) UserDAO {
   return &GORMUserDAO{
      db: db,
   }
}
```

##### 改造 UserCache

这里实现只有一个，叫做 RedisUserCache，意思就是它是基于 Redis 来实现的。这意味着将来你可以：

• 提供本地缓存实现。
• 提供 Memcache 实现。
• 提供本地缓存 + Memcache 双重缓存的实现。
• 甚至于还可以进一步提供各种缓存模式的实现。

##### 改造 UserRepository

这里实现只有一个，叫做CachedUserRepository，意思就是使用了缓存
的实现。将来你可以考虑：

• 不使用缓存，或者使用不同的缓存。
• 甚至不用数据库，使用 NoSQL 啥的。

## 单元测试

### 简单使用与介绍

各种环境全部运行起来后，出了bug，修该代码后，又要重新运行所有环境，非常麻烦。因此需要测试。正常的业务开发之后的测试流程，都是先单元测试，后集成测试。

• 单元测试：针对每一个方法进行的测试，单独验证每一个方法的正确性。

• 集成测试：多个组件合并在一起的测试，验证各个方法、组件之间配合无误。

#### go中使用单元测试

在 Go 中编写单元测试，很简单：

**• 文件名以 _test.go 结尾。**

**• 测试方法以 Test 为开头。**

**• 测试方法只接收一个参数： t *testing.T。**

可以在 IDE 中直接运行。注意，你同样可以用这个来写集成测试、冒烟测试、回归测试，都可以。

**运行模式**：

• Run：运行模式，直接运行整个测试。

• Debug：Debug 模式，你可以打断点。

• Run xxx with Coverage：运行并且输出测试覆盖率。

• 其它 Profile 都是性能分析，很少用。

**命令行运行单元测试**

一般你在考虑集成 CI 的时候，就会使用命令行来执行单元测试。
使用 go test 命令：

• go test your_test.go: 这是跑单一一个文件的测试，但你需要把 your_test.go 里面用到的文件都选进来。

• go test . :运行这个包的测试，里面所有的测试都会执行。

• go test ./... : 运行这个包的测试，包括子目录的。

#### Table Driven 模式

Go 里面，惯常的组织测试的方式，都是用 TableDriven。Table Driven 的形式主要分成三个部分：

• 测试用例的定义：即每一个测试用例需要有什么。

• 具体的测试用例：你设计的每一个测试用例都在这里。

• 执行测试用例：这里面还包括了对测试结果进行断言。

注意，你要优先使用 Table Driven，但是不用强求。你把测试用例定义看做是列名，每一个测试用例就是一行数据，就能理解 Table Driven 这个含义了。

<img src="assets/image-20240909221626534.png" alt="image-20240909221626534" style="zoom:25%;" />

#### 测试用例定义

我总结的测试用例定义，最完整的情况下应该包含：

• **名字**：简明扼要说清楚你测试的场景，建议用中文。
• **预期输入**：也就是作为你方法的输入。如果测试的是定义在类型上的方法，那么也可以包含类型实例。
• **预期输出**：你的方法执行完毕之后，预期返回的数据。如果方法是定义在类型上的方法，那么也可以包含执行之后的实例的状态。
• **mock**：每一个测试需要使用到的 mock 状态。单元测试里面常见，集成测试一般没有。
• **数据准备**：每一个测试用例需要的数据。集成测试里常见。
• **数据清理**：每一个测试用例在执行完毕之后，需要执行一些数据清理动作。集成测试里常见。

最完整的意思是：如果你要测试的方法很简单，那么你用不上全部字段。



### 测试Handler

#### 构造 HTTP 请求

因为这里还是单元测试，所以没有必要真的经过网络发起 HTTP 请求，而是可以考虑使用编程手段，构造HTTP 请求。

我们可以通过控制 HTTP 方法、URL 和传入的Body，构造出任何一种情况。

```go
//构造http请求
req, err := http.NewRequest(http.MethodPost, "/users/signup",
   bytes.NewBuffer([]byte(`
   {
     "email": "123@qq.com",
     "password": "hello@123",
     "confirm_password": "hello@123"
   }
   `)))
```

#### 验证HTTP响应

httptest 包里面已经提供了这么一个东西，可以帮助我们记录响应。也就是 httptest.Recorder。从右图中你也能看出来，通过这个 Recorder，我们能够知道，响应究竟写了些什么。

```go
//初始化一个响应体
resp := httptest.NewRecorder()
//gin会处理这个请求
//响应写回到resp里
server.ServeHTTP(resp, req)
```

#### mock工具

serHandler 在初始化的时候，是需要传入 UserService 和 CodeService 的，怎么办？如果单元测试也要构造这两个 Service，岂不是得一路构造到 DAO，然后就需要在数据库中准备数据？

所以可以用到mock工具生成测试用的模拟UserService 和 CodeService。，模拟一下调用获取返回值即可。它分成两个部分：

• mockgen：命令行工具。
• 测试中使用的控制 mock 对象的包。

##### **安装命令行工具：**

```go
go install go.uber.org/mock/mockgen@latest
```

##### 生成mock实现

mockgen 一般要指定三个参数：

• source：也就是你接口所在的文件。
• destination：也就是你生成代码的目标路径。
• package：也就是生成代码的文件的 package。

例如这个命令

```go
mockgen -source=./internal/service/user.go -package=svcmocks -destination=./internal/service/mocks/user.mock.go
```

后续就可以在测试中使用user.mock.go了

#### mock使用

**主要对测试的东西使用的依赖使用mock模拟**，使用起来很简单，都是一样的套路：

- **初始化控制器，这里是 ctrl。**
- **创建模拟的对象，这里是 usersvc。**
- **设计模拟调用**
  - **先调用 EXPECT，不要忘了。**
  - **调用同名方法，传入模拟的条件。**
  - **指定返回值。**

注意事项：你设计了几个模拟调用，在使用的时候就都要用上，而且顺序也要对上！！！！不能多！！！
不能少！！！不能乱！！！记住一条原则：**后续但凡出现和 mock 有关的错误，你就检查多了没，少了没，漏了没，条件对上了没。**

```go
func TestMock(t *testing.T) {
   //先创建一个mock的控制器
   ctrl := gomock.NewController(t)
   //每个测试结束都要调用Finish
   //然后mock就会验证你的验证流程是否符合预期
   defer ctrl.Finish()
   //调用user.mock.go文件中的方法生成模拟的service
   usersvc := svcmocks.NewMockUserService(ctrl)
   //开始设计一个Signup的模拟调用
   //模拟的条件是gomock.Any,gomock.Any
   //然后设置Signup的返回值
   usersvc.EXPECT().SignUp(gomock.Any(), domain.User{
      Email: "123@qq.com",
   }).Return(errors.New("mock error"))

   err := usersvc.SignUp(context.Background(), domain.User{
      Email: "123@qq.com",
   })
   t.Log(err)
}
```

#### handler测试核心

一个测试的执行过程就是：

• 准备一个 gin.Engine，并且注册路由。
• 准备请求。
• 准备接收响应的 Recorder。
• 直接发起调用，也就是假装收到了 HTTP 请求。
• 比较 Recorder 里面记录的响应。

注意，当你调用 ServeHTTP 的时候，效果等价于server 真的从网络里面收到了一个请求。

```go
t.Run(tc.name, func(t *testing.T) {
   //先创建一个mock控制器
   ctrl := gomock.NewController(t)
   //每个测试结束都要调用Finish
   //然后mock就会验证测试流程是否符合预期
   defer ctrl.Finish()

   //获取默认的gin对象
   server := gin.Default()
   //创建模拟对象，并设置模拟调用
   h := NewUserHandler(tc.mock(ctrl), nil)
   h.RegisterRoutes(server)
   //构造http请求
   req, err := http.NewRequest(http.MethodPost, "/users/signup",
      bytes.NewBuffer([]byte(tc.reqBody)))
   require.NoError(t, err)
   //数据是json格式
   req.Header.Set("Content-Type", "application/json")

   //初始化一个响应体
   resp := httptest.NewRecorder()
   //gin会处理这个请求
   //响应写回到resp里
   server.ServeHTTP(resp, req)

   t.Log(resp)
   assert.Equal(t, tc.wantCode, resp.Code)
   assert.Equal(t, tc.wantBody, resp.Body.String())
})
```

#### 定义测试用例

根据Table Driven 中的匿名结构体的字段设计用例即可。

```go
{
   name: "注册成功",
   mock: func(ctrl *gomock.Controller) service.UserService {
      usersvc := svcmocks.NewMockUserService(ctrl)
      usersvc.EXPECT().SignUp(gomock.Any(), domain.User{
         Email:    "123@qq.com",
         Password: "hello@123",
      }).Return(nil)
      return usersvc
   },
   reqBody: `{       
      "email": "123@qq.com",
      "password": "hello@123",
      "confirm_password": "hello@123"
      }`,
   wantCode: 200,
   wantBody: "注册成功",
},
```

mock字段是一个函数，在其中使用mock，初始化控制器，创建模拟对象，设计模拟调用。

reqBody是请求体

#### 步骤总结

- 使用mock工具生成测试所需的依赖，比如handler的service，service的dao
- 用例匿名结构体定义。
- 实现并执行测试用例的整体代码。
- 设计测试用例运行

### 测试dao

和其它层次的测试不一样，DAO 的测试要使用一个新的工具 —— `sqlmock` 来测试。因为 GORM 本身并没有提供一个接口给我们操作，导致我们没办法生成 mock 代码。为什么不用基于文件/内存的数据库来执行单元测试呢？比如说用 sqlite?因为，只要真的使用数据库，你就要操心准备数据的事情了，效率太低。

```go
go get github.com/DATA-DOG/go-sqlmock
```

基本用法：

• 用 sqlmock 来创建一个 db。
• 设置模拟调用。
• 使用 db 来测试代码：在使用 GORM 的时候

就是让 GORM 使用这个 db。



## 集成测试

## 自由切换短信服务商（写进面试）
